/*
 * These routines are used to compile regular  expressions
 * and match  the  compiled expressions against lines.  
 * The regular expressions compiled are in the form used
 * by ed.
 */
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <errno.h>
#include "regexpr.h"

#ifdef __cplusplus
extern "C" {
#endif

/* 
 * constants for re's
 */
#define CBRA 	2
#define CCHR 	4
#define CDOT	8
#define CCL		12
#define NCCL	16
#define CDOL	20
#define CEOF	22
#define CKET	24
#define CBACK	36
#define CSTAR	01

#define ESIZE	512
#define NBRA	9

extern int nbra, regerrno, reglength;
extern char *loc1, *loc2, *locs;

static char circf;

/*
 * The parameter instring is a  null-terminated  string 
 * representing the regular expression.
 * 
 * The  parameter expbuf points to the place where the 
 * compiled regular expression is to be placed.  If expbuf
 * is NULL, compile uses malloc to allocate the space for
 * the compiled regular expression.  If an error occurs, 
 * this space  is  freed. It is the user's responsibility
 * to free unneeded space after the compiled regular 
 * expression is no longer needed.
 * 
 * The parameter endbuf is one more than  the  highest  
 * address where  the  compiled regular expression may be
 * placed.  This argument is ignored if expbuf  is  NULL.
 * If  the  compiled expression  cannot  fit  in  
 * (endbuf-expbuf)  bytes, compile returns NULL and 
 * regerrno is set to 50.
 *
 * If compile succeeds, it returns  a  non-NULL  pointer
 * whose value  depends  on  expbuf.   If expbuf is 
 * non-NULL, compile returns a pointer to the byte after
 * the  last  byte  in  the compiled  regular  expression.
 * The  length of the compiled regular expression is stored 
 * in reglength.  Otherwise,  compile returns a pointer to
 * the space allocated by malloc.
 *
 * If  an  error is detected when compiling the regular 
 * expression, a NULL pointer is returned from compile  
 * and  regerrno is set to one of the non-zero error
 * numbers indicated below:
 *
 *		          ERROR     MEANING

          11        Range endpoint too large.

          16        Bad number.

          25        "\digit" out of range.

          36        Illegal or missing  delimiter.

          41        No remembered search string.

          42        \( \) imbalance.

          43        Too many \(.

          44        More than two numbers given in \{ \}.

          45        } expected after \.

          46        First number exceeds second in \{ \}.

          49        [ ] imbalance.

          50        Regular expression overflow.


 */

char *
compile (const char *instring, char *expbuf, char *endbuf) {
	int c;
	char *sp = (char *)instring;
	char *ep = expbuf;
	char *lastep = 0;
	char bracket[NBRA];
	char *bracketp = &bracket[0];
	bool inUseMalloc = false;
	
	if ( !expbuf ) {
		expbuf = (char *)malloc(ESIZE);
		if ( !expbuf ) {
			perror("malloc");
			exit(-1);
		}
		inUseMalloc = true;
		endbuf = expbuf + ESIZE;
		memset(expbuf, 0, ESIZE);
		ep = expbuf;
	}
	
	if ( sp == 0 || *sp == '\0' ) {
		if ( expbuf && inUseMalloc )
			free (expbuf);
		regerrno = 41;
		reglength = 0;
		return 0;
	}
	
	if ( *sp == '^' ) {
		circf = 1;
		sp++;
	} else {
		circf = 0;
	}
		
	while (1) {
		if ( ep >= endbuf ) {
			regerrno = 50;
			if ( expbuf && inUseMalloc )
				free (expbuf);
			return 0;
		}
		
		// terminating condition:
		if ( ( c = *sp++ ) == '\0' ) {
			if ( bracketp != bracket ) {
				if ( expbuf && inUseMalloc )
					free (expbuf);
				regerrno = 42;
				return 0;
			}
			
			*ep++ = CEOF;
			*ep = 0;
			reglength = ep - expbuf;
			if ( inUseMalloc ) {
				return expbuf;
			} else {
				return ep;
			}
		}
		
		if ( c != '*' ) lastep = ep;
		
		switch (c) {
			case '.': *ep++ = CDOT; continue;
			
			case '*':
				if ( lastep == 0 || *lastep == CBRA || *lastep == CKET )
					goto defchar;
				*lastep |= CSTAR;
				continue;
				
			case '$':
				if ( *sp != '\0' ) goto defchar;
				*ep++ = CDOL;
				continue;
			
defchar:
			default:
				*ep++ = CCHR;
				*ep++ = c;
		} // end switch
		
	} // end while
} // end compile

/**
 * Function: step (string, expbuf)
 *
 * Match the argument string against the compiled re:
 *
 * The  first  parameter  to  step  is a pointer to a
 * string of characters to be checked for a match.  This
 * string should be null-terminated.
 *
 * The  parameter  expbuf  is  the  compiled regular
 * expression obtained by a call of the function compile.
 *
 * The function step  returns  non-zero  if  the  given 
 * string matches  the regular expression, and zero if the 
 * expressions do not match.  If there is a match, two  
 * external  character pointers  are set as a side effect
 * to the call to step.  The variable set in step is loc1.
 * loc1  is  a  pointer  to  the first  character  that  
 * matched the regular expression.  The variable loc2
 * points to the character after the last character  that
 * matches the regular expression.  Thus if the regular
 * expression matches the entire line, loc1 points  to  
 * the first character of string and loc2 points to the 
 * null at the end of string.
 * 
 * The purpose of step is to step through the  string 
 * argument until  a  match  is  found  or  until  the  
 * end of string is reached.  If the regular  expression
 * begins  with  ^,  step tries  to  match  the regular 
 * expression at the beginning of the string only.
 *
 */
int
step(const char *string, const char *expbuf) {
	char c;
	char *p1 = (char *)string;
	char *p2 = (char *)expbuf;
	
	if (circf) {
		loc1 = p1;
		return advance(p1, p2);
	}
	/*
	 * fast check for first character:
	 */
	if ( *p2 == CCHR ) {
		c = p2[1];
		do {
			if ( *p1 != c ) continue;
			if ( advance(p1, p2) ) {
				loc1 = p1;
				return 1;
			}
		} while ( *p1++ );
		return 0;
	}
	
	/*
	 * Regular algorithm
	 */
	do {
		if ( advance(p1, p2) ) {
			loc1 = p1;
			return 1;
		}
	} while ( *p1++ );
	return 0;
}

/**
 * Function advance (string, expbuf)
 *
 * Try to match the next thing in the dfa:
 *
 * The function advance has the same arguments and side
 * effects as step, but it always restricts matches to 
 * the beginning of the string.
 * 
 */
int
advance(const char *string, const char *expbuf) {
	char *lp = (char *)string;
	char *ep = (char *)expbuf;
	char *curlp;
	
	while (1)  {
		switch ( *ep++ ) {
			case CCHR:
				if ( *ep++ == *lp++ ) continue;
				return 0;
			case CDOT:
				if ( *lp++ ) continue;
				return 0;
			case CDOL:
				if ( *lp == '\0' ) continue;
				return 0;
			case CEOF:
				loc2 = lp;
				return 1;
			
			case CDOT|CSTAR:
				curlp = lp;
				while ( *lp++ )
					;
				goto star;
			case CCHR|CSTAR:
				curlp = lp;
				while ( *lp++ == *ep )
					;
				ep++;
				goto star;
				
star:
		do {
			if ( --lp == locs ) break;
			if ( advance(lp, ep) ) 
				return 1;
		} while (lp > curlp);
		return 0;
		
			default:
				return 0;
				
		} // end of switch
		
	} // end of while
	
} // end of advance




#ifdef __cplusplus
}
#endif